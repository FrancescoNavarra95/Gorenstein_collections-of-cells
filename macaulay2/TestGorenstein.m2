---------------------------------------------------------------------------------------------------
-- COLLECTIONS OF CELLS, BINOMIAL IDEALS AND GORENSTEIN PROPERTY
---------------------------------------------------------------------------------------------------
--
-- This Macaulay2 script is intended to test the following conjecture:
-- If P is a domino-stable collection of cells and the coordinate ring K[P] is not a domain,
-- then K[P] is Gorenstein.
--
-- The implementation is organised in two concise sections:
--   1. Inner 2-minor ideal of a collection of cells (helper and construction functions)
--   2. Conjecture test
--
-- Important prerequisites:
--   * The Macaulay2 packages "Binomials" and "TorAlgebra" are required by the
--     TestGor function. They must be loaded in the current session prior to
--     invoking TestGor.
--
--
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
-- INNER 2-MINOR IDEAL OF A COLLECTION OF CELLS
--
-- This section provides routines to construct the polynomial ring attached to a
-- collection of cells and the ideal generated by its inner 2-minors. The inner
-- 2-minor ideal is generated by binomials corresponding to the inner intervals
-- determined by pairs of opposite corners of rectangles contained in the
-- collection.
--
-- A collection is encoded as a list Q, whose elements are the cells, each represented 
-- by its diagonal corners.
--
-- Example:
--     				        __
--  			         __|__|
--   		            |__|__|      
--
--   is encoded as:  Q={{{1,1},{2,2}},{{2,1},{3,2}},{{2,2},{3,3}}}
--
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------
-- InnerInterval(A,B,Q)
--
-- Given a collection of cells Q and two corner vertices A (lower-left) and B
-- (upper-right), return true if the axis-aligned rectangle [A,B] is an inner
-- interval of Q, i.e. every cell in the rectangle belongs to Q. Otherwise
-- return false.
---------------------------------------------------------------------------------------------------
InnerInterval=(A,B,Q)->(
    C:=B-{1,1};
    if C==A then return true;
    if member({C,B},Q)==false then return false;
    tag=true;
    for i from A#1+1 to B#1 do (
        for j from A#0 to B#0-1 do (
            if member({{j,i-1},{j+1,i}},Q)==false then return false;
        );
    );
    return tag;
);

---------------------------------------------------------------------------------------------------
-- PolyoRing(Q)
--
-- Construct and return the polynomial ring associated to the vertex set of
-- the collection Q. Variables are indexed by the integer coordinates of the
-- vertices appearing in Q. The ring is formed over the rational field QQ.
---------------------------------------------------------------------------------------------------
PolyoRing=(Q)->(
    V={};
    for i from 0 to #Q-1 do(
        V=join(V,toList ({Q#i#0#0,Q#i#0#1}..{Q#i#1#0,Q#i#1#1}));
    );
    V=set V;
    V=rsort(toList(V));
    Gen={};                                      
    for i from 0 to #V-1 do(
        Gen=join(Gen,{x_(V#i#0,V#i#1)});
    );
    R=QQ[Gen];
    return R;
);


---------------------------------------------------------------------------------------------------
-- PolyoIdeal(Q)
--
-- Given a collection of cells Q, construct the ideal generated by the inner
-- 2-minors. These binomials correspond to pairs of opposite corners (a,b)
-- and (c,d) of an inner interval: x_{a,b}*x_{c,d} - x_{a,d}*x_{c,b}.
---------------------------------------------------------------------------------------------------
PolyoIdeal=(Q)->(
    Binomials={};
    for i from 0 to #Q-1 do(
        lLowCorner = Q#i#0;
            for j from 0 to #Q-1 do(
                 rUpCorner = Q#j#1;
                 if lLowCorner#0<rUpCorner#0 and lLowCorner#1<rUpCorner#1 then (
                     if InnerInterval(lLowCorner,rUpCorner,Q) then (
                         a=lLowCorner#0;
                         b=lLowCorner#1;
                         c=rUpCorner#0;
                         d=rUpCorner#1;
                         Binomials=join(Binomials,{x_(a,b)*x_(c,d)-x_(a,d)*x_(c,b)});
                     );
                 );
            );
    );
    Binomials = set Binomials;
    Binomials = toList Binomials;
    I=ideal(Binomials);
    return I;
);

---------------------------------------------------------------------------------------------------
---------------------------------------------- CONJECTURE TEST ------------------------------------
---------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
-- isPalindromic(f)
--
-- Determine whether a polynomial f in QQ[x] is palindromic. 
-- If f = a_0 + a_1 x + ... + a_d x^d then f is palindromic if a_i = a_{d-i} for all i = 0, ..., d.
-- The function returns true when palindromic and false otherwise.
--
---------------------------------------------------------------------------------------------------

isPalindromic=(f)->(
    Coeff := flatten entries ((coefficients f)#1);
    degPol := #Coeff-1;
    indx := floor(degPol/2);
    for i from 0 to indx do (
        if Coeff#i != Coeff#(degPol-i) then return false;
    );
    return true;
);

--------------------------------------------------------------------------------------------------
--TestGor(L) 
--
-- Given a list L of collections of cells (each encoded as in the header),
-- TestGor verifies the conjecture for every collection in L. Concretely, for
-- each collection P it checks whether:
--   (i)  the inner 2-minor ideal I(P) is not prime (equivalently K[P] is not a domain);
--   (ii) the switching rook polynomial (computed via the Hilbert series)
--        is palindromic, equivalently, the collection of cells is domino-stable;
--   (iii) the coordinate ring K[P] is Gorenstein.
--
-- The routine returns the list of counterexamples (collections for which (i)
-- and (ii) hold but (iii) fails). When no counterexamples are found it prints
-- "Conjecture is ok". Additionally it writes a file PalGor_<rank>.txt that
-- contains the collections satisfying (i), (ii), and (iii).
--
-- Note: The function relies on the presence of functions binomialIsPrime,
-- isGorenstein provided by Macaulay2 packages "Binomials" and  "TorAlgebra". 
-- Ensure those packages are loaded.
--------------------------------------------------------------------------------------------------
TestGor = (L) -> (
    rank := #(L#0);
    numberCollections := #L;

    listNonPrime = {};
    listPalindromic = {};
    listPalGor = {};
    counterExample = {};

    for i from 0 to #L-1 do (
        if i % 100 == 0 then print("Iteration " | toString(i+1) | " over " | toString(numberCollections));
        R = PolyoRing(L#i);
        I = PolyoIdeal(L#i);
        if not binomialIsPrime I then (
            listNonPrime = append(listNonPrime, L#i);
            h1 = numerator reduceHilbert hilbertSeries I;
            if isPalindromic(h1) then (
                listPalindromic = append(listPalindromic, L#i);
                if isGorenstein I then (
                    listPalGor = append(listPalGor, L#i)
                ) else (
                    counterExample = append(counterExample, L#i)
                );
            );
        );
    );

    fileName = "PalGor_" | toString(rank) | ".txt";
    fileName << listPalGor << endl << close;

    print("# non-prime collections of cells: " | toString(#listNonPrime) | " over " | toString(numberCollections));
    print("# domino-stable collections of cells, among non-prime: " | toString(#listPalindromic));
    print("# domino-stable Gorenstein collections of cells, among non-prime: " | toString(#listPalGor));

    if counterExample == {} then print("Conjecture is ok") else return counterExample;
);

---------------------------------------------------------------------------------------------------
-- EXAMPLE OF USE

-- loadPackage "Binomials";
-- loadPackage "TorAlgebra";
-- load "TestGorenstein.m2";
-- L = value get("weak_polyplets_n4.txt");
-- TestConj(L);
---------------------------------------------------------------------------------------------------

